## 스프링 ##
스프링 데이터, 스프링 세션, 스프링 시큐리티 등 수많은 부가적인 프로젝트 존재.  
이러한 부가적인 기능들을 사용할 스프링 프레임워크와 한데 뭉쳐 쉽게 사용할 수 있도록 도와주는 스프링 부트를 학습해야 한다.  
  
### 스프링 프레임워크 ###
여러 기술이 합쳐져 만들어진 프레임워크.  
해당 프레임워크 내에서 웹 기술, 데이터 접근, 기술 통합, 테스트가 모두 지원된다.  
핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트  
  - 웹 기술 : WebFlux
  - DB 접근 기술 : 트랜잭션, JDBC, ORM, XML
  - 그 외 : 스케줄링 통한 예약 기능, 이메일 전송, 캐시, JUnit 등  
  
### 스프링 부트 ###
기존 스프링 프레임워크에서는 프로젝트 배포를 위해 Tomcat 서버 구축 후 특정 경로에 해당 프로젝트를 빌드한 war나 jar 파일을 올리고  
설정 맞춘 뒤 구동해야 동작, 뿐만 아니라 버전에 맞는 외부 라이브러리를 사용하기 위해 직접 테스트하는 등 모든 초기 설정을 직접 해야하는 번거로움이 있었다.  
  
이를 해결하기 위해 나온 것이 스프링 부트.  
xml을 통해 직접 설정해야 했던 부분들을 관례에 따른 기본 설정으로 세팅해놓고 명시적으로 설정을 변경해야하는 경우에만 properties나 yml을 통해 변경할 수 있다.  
  
- 웹 서버를 자체 내장하여 별도의 웹 서버를 설치하지 않아도 된다
- 손쉬운 빌드 구성을 위한 starter 종속성을 제공한다
- 스프링과 서드파티(3rd party) 외부 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정
  
### 스프링은 자바 기반 프레임워크이다 ###
자바는 <b>객체지향 언어</b>이다.   
스프링은 객체지향 언어의 특징인 유연성과 확장성을 잘 살리는 프레임워크로써 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와준다.  
  
----------------------------------------------------------------------------------------------------------------  
## 좋은 객체지향 프로그래밍이란? ##
객체 지향 프로그래밍 : 객체 하나하나가 메시지를 주고 받으며 로직을 수행하는 협력의 형태. 유연하고 변경이 용이하다.  
  
### 다형성(Polymorphism) ###
운전자 -> 운전 기능만 이해하면 될 뿐 자동차별 운전법을 따로따로 익힐 필요는 없다.  
즉, 자동차 역할이 제공해야할 기능들만 구현한다면 얼마든지 새로운 자동차를 만들 수 있다는 확장성을 제공한다.  
<b>해당 객체는 해당 객체의 책임만 성실히 이행하면 내부가 어떤가는 중요하지 않다.</b>  
  
### 역할과 구현을 분리하라 ###
유연성, 변경 및 확장에 용이하기 위해 역할과 구현을 분리해야 한다.  
클라이언트(운전자)는 대상(자동차)의 내부가 어떤지 알 필요 없고 그 기능만 잘 작동하면 된다.  
구현 대상의 구조나 그 자체가 변경되도 영향을 받지 않아야 한다.  
  
<자바에서의 역할과 구현 분리 방법>  
다형성을 이용한다.  
객체를 설계할 때 역할과 구현을 분리하여 작성한다.  
객체 설계시 역할(인터페이스)를 먼저 작성 후 그 역할을 수행하는 구현 객체를 만든다.  
- 역할 : 인터페이스
- 구현 : 인터페이스 구현한 클래스, 구현 객체  
  
### 다형성의 본질 ###
- 클라이언트를 변경하지 않고 서버에서 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하기 위해 협력이라는 객체 사이의 관계에서 시작해야 한다.
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.  
  
### 한계점 ###  
- 역할(인터페이스) 자체가 변하면, 이를 구현한 구현체 뿐만 아니라 클라이언트, 서버 모두 변경되어야 한다.
- 그러므로 인터페이스를 안정적으로 잘 설계하는 것이 중요하다  
  
### 스프링의 객체 지향 ###
스프링은 객체지향 개념 중 가장 중요한 다형성의 장점을 극대화한다.  
제어의 역전(IoC), 의존관계 주입(DI) 등 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원한다.  
  
## 좋은 객체 지향 설계의 5가지 원칙 (SOLID) ##
- SRP 단일 책임 원칙  
Single Responsibility Principle  
  - 한 클래스는 하나의 책임만 가져야 한다
  - 하나의 책임은 모호하다
    - 책임은 클 수도, 작을 수도 있다
    - 문맥과 상황에 따라 다르다
  - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적을 수록 단일 책임 원칙을 잘 따른 것이다.
  - ex) UI 변경, 객체의 생성과 사용을 분리
  
- OCP 개방-폐쇄 원칙  
Open/Closed Principle  
  - 소프트웨어 요소는 <b>확장</b>에는 열려있으나 <b>변경</b>에는 닫혀있어야 한다.
  - 코드를 변경하지 않고 어떻게 확장하는가 -> "다형성"
  
- LSP 리스코프 치환 원칙  
Liskov Substitution Principle  
  - 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 컴파일 단계에서 생기는 문제는 아니지만 클라이언트는 특정 역할을 사용할 때 해당 기능에 대해 기대하는 책임이 있기에 해당 책임을 수행할 것을 믿고 동작하는 것이기에 이 원칙이 필요하다.
  
- ISP 인터페이스 분리 원칙  
Interface Segregation Principle  
  - 클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않아야 한다.
  - 범용 인터페이스 하나보다는 특정 목적을 위한 인터페이스가 여러 개 있는 것이 좋다. 그러므로 클라이언트는 꼭 필요한 메소드만 이용할 수 있다. 
  - 작은 단위 -> 역할 인터페이스라고 부른다.  
```java
public interface Car {
    void driving();
    // 범용적인 인터페이스보다는
    
    void go();
    void left();
    void stop();
    void right();
    // 특정 기능 수행하는 작은 단위로 분리하는 것이 내부 의존성 역화시켜 리팩토링, 수정, 재배포를 쉽게 한다.
    
}

``` 
  
- DIP 의존관계 역전 원칙  
Dependency Inversion Principle  
  - 구현 클래스가 아닌 인터페이스에 의존해야 한다.
  - 운전자는 운전을 하기 위해 자동차의 역할을 알아야 하지 차종에 대해 알아야 하는 것이 아니다.
  - *프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.*


=> DIP 의존관계 역전 원칙에서는 인터페이스에 의존, 구현체에 의존하지 말라고 하지만 OCP 원칙은 직접 구현 클래스를 대입해주면서 구현체에 의존성을 가진다.  
  

----------------------------------------------------------------------------------------------------------------  
## 객체지향 설계와 스프링 ##
DIP, OCP가 다형성에 위반 -> 이를 해결하기 위한 프레임워크가 스프링  
  
스프링에서는 DIP, OCP가 가능하면서 다형성이 되도록 지원한다.
- DI(Dependency Injection) : 의존 관계, 의존성 주입
- DI 컨테이너 제공
  
이렇게 DI 컨테이너를 통해 의존성이 주입되면서 OCP, DIP 원칙을 지킬 수 있기에 클라이언트의 코드 변경 없이 기능 확장이 가능해진다.

=> 객체지향 설계 5가지 원칙을 지키며 개발할 수 있는 프레임워크 = 스프링(DI 컨테이너)  
  
